From 4947cdd8477c7964049d35968206abfa6c99e198 Mon Sep 17 00:00:00 2001
From: Victor Herrero Otal <victor.herrero.otal@sap.com>
Date: Thu, 23 May 2024 16:15:58 +0200
Subject: [PATCH 04/11] Adapt VPA metrics to new solution CustomResourceState

This commit adds the necessary configuration changes to readd the VPA
metrics using the new strategy CustomResourceState from the
kube-state-metrics. Such configuration is created programmatically thanks
to the the kube-state-metrics dependency downloaded in the previous
commit. This commit also runs `go mod tidy` in order to make this
dependency direct.

The new CustomResourceState configuration is stored in a ConfigMap and
mounted into the kube-state-metrics deployment using the
`--custom-resource-state-config-file`. There is an alternative command
flag `--custom-resource-state-config` to pass such configuration inline
but the resulting configuration is very lengthy, which would make the
kube-state-metrics deployment document not so readable.

We tried to preserve the old metric labels and naming as much as
possible. However, there are a few changes:

1. We can't have one common metric for several resources (e.g., CPU
  and memory) and distinguish between them via labels. Instead, we
  need to migrate to one specific metric per resource. For instance,
  previously we had a `target` metric with labels `resource=cpu`
  or `resource=memory` to indicate the value corresponding to CPU or
  memory. After this change two metrics are added: `target_cpu` and
  `target_memory`. Nevertheless, we consider this as an improvement
  because values in the new metrics are not mixing units as before
  (cores were used for the CPU and bytes for the memory).
2. Using `CustomResourceState` prefixes the metric name with
   `kube_customresource` by default. Therefore, the old prefix
   `kube_verticalpodautoscaler` becomes now
   `kube_customresource_verticalpodautoscaler`. Such default prefix
   can be overwritten to match the one we want, but we choose not to
   so that the new name reflects better that the metric is generated
   by the `CustomResourceState`.
3. The property `nilIsZero` is set to true for the recommendation
   metrics to set the value to zero if the recommendation path does not
   exist in the VPA spec file (i.e., it doesn't have a recommendation).
   In the past, the time series would simply not exist. Since a
   recommendation to 0 does not make sense, this is a way, e.g., in the
   dashboard, to know there is no recommendation at all, rather than
   relying on not having data, which could also be the case if there is
   an issue and metrics are missing.
4. Metrics containing `container_policies` in their name have been
   renamed to `containerpolicies` to respect the containerPolicies key
   in the spec file (similar to resourcePolicy or
   containerRecommendations). This way, the metric format is unified to
   use underscores to separate keys in the path.
5. The `CustomResourceState` documentation does not mention that
   kube-state-metrics needs `get` permissions on RBAC-enabled clusters,
   but only `list` and `watch`. Therefore, the old `get` permissions are
   removed.

A unit test is added to assert the generated configuration matches the
one originally generated for testing. The test expectation is saved into
a yaml file and committed to git. The test saves the generated
configuration in a different file in the temporary folder (but does not
commit it). The benefit of this approach is that it helps comparing the
actual and expected configuration, no matter how large the files are: we
have two separate files that we can compare using any tool.

The `expectedCustomResourceStateConfig()` utility returns the expected
CustomResourceState config and also asserts that the actual value is the
same. This function is to be used to load the test expectation during
the test setup. The assertion is performed inside this function to allow
to give more human readable errors when the long config document actually
differs. When the assertion fails, a custom message is shown. It tries to
mimic the wording from usual ginkgo test runs but adds a hint in the end
on how to use the diff command to see the diff. This of course will only
work on UNIX systems. Developers can review this diff and react
accordingly e.g., check if there is a bug in the code or if indeed the
expectation has to be changed.

Finally, this commit also runs `go mod tidy` to make the new
kube-state-metrics dependency direct.

Co-authored-by: Istvan Zoltan Ballok <istvan.zoltan.ballok@sap.com>
---
 go.mod                                        |   5 +-
 go.sum                                        |  10 -
 .../kubestatemetrics/customresourcestate.go   | 138 +++++++++
 .../customresourcestate_test.go               |  51 +++
 .../kubestatemetrics/kubestatemetrics.go      |  10 +-
 .../kubestatemetrics/kubestatemetrics_test.go |  81 +++--
 .../monitoring/kubestatemetrics/resources.go  | 103 +++++--
 .../custom-resource-state.expectation.yaml    | 290 ++++++++++++++++++
 8 files changed, 625 insertions(+), 63 deletions(-)
 create mode 100644 pkg/component/observability/monitoring/kubestatemetrics/customresourcestate.go
 create mode 100644 pkg/component/observability/monitoring/kubestatemetrics/customresourcestate_test.go
 create mode 100644 pkg/component/observability/monitoring/kubestatemetrics/testdata/custom-resource-state.expectation.yaml

diff --git a/go.mod b/go.mod
index 4ed540c91..7d4856da2 100644
--- a/go.mod
+++ b/go.mod
@@ -70,6 +70,7 @@ require (
 	k8s.io/kube-aggregator v0.29.6
 	k8s.io/kube-openapi v0.0.0-20231010175941-2dd684a91f00
 	k8s.io/kube-proxy v0.29.6
+	k8s.io/kube-state-metrics/v2 v2.12.0
 	k8s.io/kubelet v0.29.6
 	k8s.io/metrics v0.29.6
 	k8s.io/pod-security-admission v0.29.6
@@ -168,7 +169,6 @@ require (
 	github.com/mailru/easyjson v0.7.7 // indirect
 	github.com/mattn/go-colorable v0.1.13 // indirect
 	github.com/mattn/go-isatty v0.0.20 // indirect
-	github.com/matttproud/golang_protobuf_extensions/v2 v2.0.0 // indirect
 	github.com/miekg/dns v1.1.58 // indirect
 	github.com/mitchellh/copystructure v1.2.0 // indirect
 	github.com/mitchellh/go-homedir v1.1.0 // indirect
@@ -187,7 +187,6 @@ require (
 	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
 	github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f // indirect
 	github.com/mxk/go-flowrate v0.0.0-20140419014527-cca7078d478f // indirect
-	github.com/oklog/run v1.1.0 // indirect
 	github.com/opencontainers/go-digest v1.0.0 // indirect
 	github.com/opencontainers/runtime-spec v1.1.0 // indirect
 	github.com/opencontainers/selinux v1.11.0 // indirect
@@ -195,7 +194,6 @@ require (
 	github.com/pelletier/go-toml/v2 v2.2.2 // indirect
 	github.com/pkg/errors v0.9.1 // indirect
 	github.com/prometheus/client_model v0.6.0 // indirect
-	github.com/prometheus/exporter-toolkit v0.11.0 // indirect
 	github.com/prometheus/procfs v0.12.0 // indirect
 	github.com/redis/go-redis/extra/rediscmd/v9 v9.0.5 // indirect
 	github.com/redis/go-redis/extra/redisotel/v9 v9.0.5 // indirect
@@ -253,7 +251,6 @@ require (
 	k8s.io/gengo v0.0.0-20230829151522-9cce18d56c01 // indirect
 	k8s.io/klog v1.0.0 // indirect
 	k8s.io/kms v0.29.6 // indirect
-	k8s.io/kube-state-metrics/v2 v2.12.0 // indirect
 	k8s.io/sample-controller v0.29.3 // indirect
 	oras.land/oras-go v1.2.4 // indirect
 	sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.28.0 // indirect
diff --git a/go.sum b/go.sum
index 30f897ba4..b22cb3373 100644
--- a/go.sum
+++ b/go.sum
@@ -409,8 +409,6 @@ github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/
 github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
 github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
 github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
-github.com/matttproud/golang_protobuf_extensions/v2 v2.0.0 h1:jWpvCLoY8Z/e3VKvlsiIGKtc+UG6U5vzxaoagmhXfyg=
-github.com/matttproud/golang_protobuf_extensions/v2 v2.0.0/go.mod h1:QUyp042oQthUoa9bqDv0ER0wrtXnBruoNd7aNjkbP+k=
 github.com/miekg/dns v1.1.58 h1:ca2Hdkz+cDg/7eNF6V56jjzuZ4aCAE+DbVkILdQWG/4=
 github.com/miekg/dns v1.1.58/go.mod h1:Ypv+3b/KadlvW9vJfXOTf300O4UqaHFzFCuHz+rPkBY=
 github.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=
@@ -459,8 +457,6 @@ github.com/mxk/go-flowrate v0.0.0-20140419014527-cca7078d478f/go.mod h1:ZdcZmHo+
 github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
 github.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=
 github.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=
-github.com/oklog/run v1.1.0 h1:GEenZ1cK0+q0+wsJew9qUg/DyD8k3JzYsZAi5gYi2mA=
-github.com/oklog/run v1.1.0/go.mod h1:sVPdnTZT1zYwAJeCMu2Th4T21pA3FPOQRfWjQlk7DVU=
 github.com/onsi/ginkgo v0.0.0-20170829012221-11459a886d9c/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.11.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
@@ -503,8 +499,6 @@ github.com/prometheus/blackbox_exporter v0.24.0/go.mod h1:SfZtJPNWmR8SskeJMmggTp
 github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
 github.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=
 github.com/prometheus/client_golang v1.1.0/go.mod h1:I1FGZT9+L76gKKOs5djB6ezCbFQP1xR9D75/vuwEF3g=
-github.com/prometheus/client_golang v1.18.0 h1:HzFfmkOzH5Q8L8G+kSJKUx5dtG87sewO+FoDDqP5Tbk=
-github.com/prometheus/client_golang v1.18.0/go.mod h1:T+GXkCk5wSJyOqMIzVgvvjFDlkOQntgjkJWKrN5txjA=
 github.com/prometheus/client_golang v1.19.0 h1:ygXvpU1AoN1MhdzckN+PyD9QJOSD4x7kmXYlnfbA6JU=
 github.com/prometheus/client_golang v1.19.0/go.mod h1:ZRM9uEAypZakd+q/x7+gmsvXdURP+DABIEIjnmDdp+k=
 github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
@@ -514,12 +508,8 @@ github.com/prometheus/client_model v0.6.0 h1:k1v3CzpSRUTrKMppY35TLwPvxHqBu0bYgxZ
 github.com/prometheus/client_model v0.6.0/go.mod h1:NTQHnmxFpouOD0DpvP4XujX3CdOAGQPoaGhyTchlyt8=
 github.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
 github.com/prometheus/common v0.6.0/go.mod h1:eBmuwkDJBwy6iBfxCBob6t6dR6ENT/y+J+Zk0j9GMYc=
-github.com/prometheus/common v0.45.0 h1:2BGz0eBc2hdMDLnO/8n0jeB3oPrt2D08CekT0lneoxM=
-github.com/prometheus/common v0.45.0/go.mod h1:YJmSTw9BoKxJplESWWxlbyttQR4uaEcGyv9MZjVOJsY=
 github.com/prometheus/common v0.51.1 h1:eIjN50Bwglz6a/c3hAgSMcofL3nD+nFQkV6Dd4DsQCw=
 github.com/prometheus/common v0.51.1/go.mod h1:lrWtQx+iDfn2mbH5GUzlH9TSHyfZpHkSiG1W7y3sF2Q=
-github.com/prometheus/exporter-toolkit v0.11.0 h1:yNTsuZ0aNCNFQ3aFTD2uhPOvr4iD7fdBvKPAEGkNf+g=
-github.com/prometheus/exporter-toolkit v0.11.0/go.mod h1:BVnENhnNecpwoTLiABx7mrPB/OLRIgN74qlQbV+FK1Q=
 github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
 github.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
 github.com/prometheus/procfs v0.0.3/go.mod h1:4A/X28fw3Fc593LaREMrKMqOKvUAntwMDaekg4FpcdQ=
diff --git a/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate.go b/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate.go
new file mode 100644
index 000000000..80e9fb4cc
--- /dev/null
+++ b/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate.go
@@ -0,0 +1,138 @@
+// SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company and Gardener contributors
+//
+// SPDX-License-Identifier: Apache-2.0
+
+package kubestatemetrics
+
+import (
+	"fmt"
+	"strings"
+
+	"k8s.io/kube-state-metrics/v2/pkg/customresourcestate"
+)
+
+const (
+	customResourceStateConfigMountDir  = "/config"
+	customResourceStateConfigMountFile = "custom-resource-state.yaml"
+	customResourceStateConfigMapName   = "custom-resource-state-config"
+)
+
+func newCustomResourceStateMetricNameForVPA(path, valuePath []string) string {
+	metricName := "verticalpodautoscaler_" + strings.ToLower(strings.Join(path, "_"))
+	if len(valuePath) > 0 {
+		metricName += "_" + strings.ToLower(strings.Join(valuePath, "_"))
+	}
+
+	return metricName
+}
+
+func newCustomResourceStateGaugeMetricForVPA(path, valueFrom []string, help, unit string) customresourcestate.Generator {
+	return customresourcestate.Generator{
+		Name: newCustomResourceStateMetricNameForVPA(path, valueFrom),
+		Help: help,
+		Labels: customresourcestate.Labels{
+			CommonLabels: map[string]string{
+				"unit": unit,
+			},
+		},
+		Each: customresourcestate.Metric{
+			Type: "Gauge",
+			Gauge: &customresourcestate.MetricGauge{
+				MetricMeta: customresourcestate.MetricMeta{
+					Path: path,
+					LabelsFromPath: map[string][]string{
+						"container": {"containerName"},
+					},
+				},
+				ValueFrom: valueFrom,
+				NilIsZero: true,
+			},
+		},
+	}
+}
+
+func newCustomResourceStateMetricsForVPA() customresourcestate.Resource {
+	resource := customresourcestate.Resource{
+		GroupVersionKind: customresourcestate.GroupVersionKind{
+			Group:   "autoscaling.k8s.io",
+			Kind:    "VerticalPodAutoscaler",
+			Version: "v1",
+		},
+		Labels: customresourcestate.Labels{
+			LabelsFromPath: map[string][]string{
+				"verticalpodautoscaler": {"metadata", "name"},
+				"namespace":             {"metadata", "namespace"},
+				"target_api_version":    {"spec", "targetRef", "apiVersion"},
+				"target_kind":           {"spec", "targetRef", "kind"},
+				"target_name":           {"spec", "targetRef", "name"},
+			},
+		},
+	}
+
+	units := map[string]string{
+		"cpu":    "core",
+		"memory": "byte",
+	}
+
+	helpMessages := map[string]string{
+		"target":     "Target %s the VerticalPodAutoscaler recommends for the container.",
+		"upperBound": "Maximum %s the container can use before the VerticalPodAutoscaler updater evicts it.",
+		"lowerBound": "Minimum %s the container can use before the VerticalPodAutoscaler updater evicts it.",
+		"minAllowed": "Minimum %s the VerticalPodAutoscaler can set for containers matching the name.",
+		"maxAllowed": "Maximum %s the VerticalPodAutoscaler can set for containers matching the name.",
+	}
+
+	for _, res := range []string{"cpu", "memory"} {
+		for _, attr := range []string{"target", "upperBound", "lowerBound"} {
+			generator := newCustomResourceStateGaugeMetricForVPA(
+				[]string{"status", "recommendation", "containerRecommendations"},
+				[]string{attr, res},
+				fmt.Sprintf(helpMessages[attr], res),
+				units[res],
+			)
+
+			resource.Metrics = append(resource.Metrics, generator)
+		}
+
+		for _, attr := range []string{"minAllowed", "maxAllowed"} {
+			generator := newCustomResourceStateGaugeMetricForVPA(
+				[]string{"spec", "resourcePolicy", "containerPolicies"},
+				[]string{attr, res},
+				fmt.Sprintf(helpMessages[attr], res),
+				units[res],
+			)
+
+			resource.Metrics = append(resource.Metrics, generator)
+		}
+	}
+
+	path := []string{"spec", "updatePolicy", "updateMode"}
+	resource.Metrics = append(resource.Metrics, customresourcestate.Generator{
+		Name: newCustomResourceStateMetricNameForVPA(path, nil),
+		Help: "Update mode of the VerticalPodAutoscaler.",
+		Each: customresourcestate.Metric{
+			Type: "StateSet",
+			StateSet: &customresourcestate.MetricStateSet{
+				MetricMeta: customresourcestate.MetricMeta{
+					Path: path,
+				},
+				LabelName: "update_mode",
+				List:      []string{"Off", "Initial", "Recreate", "Auto"},
+			},
+		},
+	})
+
+	return resource
+}
+
+// NewCustomResourceStateConfig returns a new CustomResourceState configuration that can be serialized
+// and passed to the kube-state-metrics binary to create metrics from custom resource definitions
+func NewCustomResourceStateConfig() customresourcestate.Metrics {
+	return customresourcestate.Metrics{
+		Spec: customresourcestate.MetricsSpec{
+			Resources: []customresourcestate.Resource{
+				newCustomResourceStateMetricsForVPA(),
+			},
+		},
+	}
+}
diff --git a/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate_test.go b/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate_test.go
new file mode 100644
index 000000000..48b5c92d0
--- /dev/null
+++ b/pkg/component/observability/monitoring/kubestatemetrics/customresourcestate_test.go
@@ -0,0 +1,51 @@
+// SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company and Gardener contributors
+//
+// SPDX-License-Identifier: Apache-2.0
+
+package kubestatemetrics_test
+
+import (
+	"os"
+	"path/filepath"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	. "github.com/gardener/gardener/pkg/component/observability/monitoring/kubestatemetrics"
+	"github.com/gardener/gardener/third_party/gopkg.in/yaml.v2"
+)
+
+// Returns the expected CustomResourceState config and also asserts that the actual value is the same.
+// This assertion is performed inside this function to allow to give more human readable errors when the
+// long config document actually differs. This also allows to keep the expectation in a standalone yaml
+// file and to easily update it when it needs to be changed
+func expectedCustomResourceStateConfig() string {
+	defer GinkgoRecover()
+
+	rawActual, err := yaml.Marshal(NewCustomResourceStateConfig())
+	Expect(err).ToNot(HaveOccurred())
+
+	actual := string(rawActual)
+
+	expectFilePath, err := filepath.Abs("testdata/custom-resource-state.expectation.yaml")
+	Expect(err).ToNot(HaveOccurred())
+
+	rawExpect, err := os.ReadFile(expectFilePath)
+	Expect(err).ToNot(HaveOccurred())
+
+	if actual != string(rawExpect) {
+		actualFilePath := os.TempDir() + "/custom-resource-state.actual.yaml"
+		err = os.WriteFile(actualFilePath, rawActual, 0644)
+		Expect(err).ToNot(HaveOccurred())
+
+		AbortSuite("CustomResourceState configuration did not match the expectation:\n" +
+			"Expected file\n" +
+			"\t" + actualFilePath + "\n" +
+			"to match contents from file\n" +
+			"\t" + expectFilePath + "\n" +
+			"Execute 'diff -Bb " + actualFilePath + " " + expectFilePath + "' to see the difference",
+		)
+	}
+
+	return actual
+}
diff --git a/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics.go b/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics.go
index 26d2fbcce..0820aff30 100644
--- a/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics.go
+++ b/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics.go
@@ -18,6 +18,7 @@ import (
 	gardenerutils "github.com/gardener/gardener/pkg/utils/gardener"
 	"github.com/gardener/gardener/pkg/utils/managedresources"
 	secretsmanager "github.com/gardener/gardener/pkg/utils/secrets/manager"
+	"github.com/gardener/gardener/third_party/gopkg.in/yaml.v2"
 )

 const (
@@ -82,6 +83,11 @@ func (k *kubeStateMetrics) Deploy(ctx context.Context) error {
 		shootAccessSecret                *gardenerutils.AccessSecret
 	)

+	customResourceStateConfig, err := yaml.Marshal(NewCustomResourceStateConfig())
+	if err != nil {
+		return err
+	}
+
 	if k.values.ClusterType == component.ClusterTypeShoot {
 		genericTokenKubeconfigSecret, found := k.secretsManager.Get(v1beta1constants.SecretNameGenericTokenKubeconfig)
 		if !found {
@@ -102,11 +108,11 @@ func (k *kubeStateMetrics) Deploy(ctx context.Context) error {
 		registry = managedresources.NewRegistry(kubernetes.ShootScheme, kubernetes.ShootCodec, kubernetes.ShootSerializer)
 	}

-	return component.DeployResourceConfigs(ctx, k.client, k.namespace, k.values.ClusterType, k.managedResourceName(), map[string]string{v1beta1constants.LabelCareConditionType: v1beta1constants.ObservabilityComponentsHealthy}, registry, k.getResourceConfigs(genericTokenKubeconfigSecretName, shootAccessSecret))
+	return component.DeployResourceConfigs(ctx, k.client, k.namespace, k.values.ClusterType, k.managedResourceName(), map[string]string{v1beta1constants.LabelCareConditionType: v1beta1constants.ObservabilityComponentsHealthy}, registry, k.getResourceConfigs(genericTokenKubeconfigSecretName, shootAccessSecret, string(customResourceStateConfig)))
 }

 func (k *kubeStateMetrics) Destroy(ctx context.Context) error {
-	if err := component.DestroyResourceConfigs(ctx, k.client, k.namespace, k.values.ClusterType, k.managedResourceName(), k.getResourceConfigs("", nil)); err != nil {
+	if err := component.DestroyResourceConfigs(ctx, k.client, k.namespace, k.values.ClusterType, k.managedResourceName(), k.getResourceConfigs("", nil, "")); err != nil {
 		return err
 	}

diff --git a/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics_test.go b/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics_test.go
index 29c6bf983..567030a29 100644
--- a/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics_test.go
+++ b/pkg/component/observability/monitoring/kubestatemetrics/kubestatemetrics_test.go
@@ -63,11 +63,13 @@ var _ = Describe("KubeStateMetrics", func() {
 		vpaUpdateMode       = vpaautoscalingv1.UpdateModeAuto
 		vpaControlledValues = vpaautoscalingv1.ContainerControlledValuesRequestsOnly

-		serviceAccount    *corev1.ServiceAccount
-		secretShootAccess *corev1.Secret
-		vpa               *vpaautoscalingv1.VerticalPodAutoscaler
-		pdbFor            func(bool) *policyv1.PodDisruptionBudget
-		clusterRoleFor    = func(clusterType component.ClusterType) *rbacv1.ClusterRole {
+		serviceAccount               *corev1.ServiceAccount
+		secretShootAccess            *corev1.Secret
+		vpa                          *vpaautoscalingv1.VerticalPodAutoscaler
+		pdbFor                       func(bool) *policyv1.PodDisruptionBudget
+		customResourceStateConfigMap *corev1.ConfigMap
+
+		clusterRoleFor = func(clusterType component.ClusterType) *rbacv1.ClusterRole {
 			name := "gardener.cloud:monitoring:kube-state-metrics"
 			if clusterType == component.ClusterTypeSeed {
 				name += "-seed"
@@ -106,10 +108,15 @@ var _ = Describe("KubeStateMetrics", func() {
 						Resources: []string{"cronjobs", "jobs"},
 						Verbs:     []string{"list", "watch"},
 					},
+					{
+						APIGroups: []string{"apiextensions.k8s.io"},
+						Resources: []string{"customresourcedefinitions"},
+						Verbs:     []string{"list", "watch"},
+					},
 					{
 						APIGroups: []string{"autoscaling.k8s.io"},
 						Resources: []string{"verticalpodautoscalers"},
-						Verbs:     []string{"get", "list", "watch"},
+						Verbs:     []string{"list", "watch"},
 					},
 				},
 			}
@@ -230,7 +237,7 @@ var _ = Describe("KubeStateMetrics", func() {
 				args = []string{
 					"--port=8080",
 					"--telemetry-port=8081",
-					"--resources=deployments,pods,statefulsets,nodes,verticalpodautoscalers,horizontalpodautoscalers,persistentvolumeclaims,replicasets,namespaces",
+					"--resources=deployments,pods,statefulsets,nodes,horizontalpodautoscalers,persistentvolumeclaims,replicasets,namespaces",
 					"--metric-labels-allowlist=nodes=[*]",
 					"--metric-annotations-allowlist=namespaces=[shoot.gardener.cloud/uid]",
 					"--metric-allowlist=" +
@@ -279,16 +286,39 @@ var _ = Describe("KubeStateMetrics", func() {
 						"kube_statefulset_status_replicas_current," +
 						"kube_statefulset_status_replicas_ready," +
 						"kube_statefulset_status_replicas_updated," +
-						"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_target," +
-						"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound," +
-						"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound," +
-						"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_minallowed," +
-						"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_maxallowed," +
-						"kube_verticalpodautoscaler_spec_updatepolicy_updatemode",
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu," +
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory," +
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu," +
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory," +
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu," +
+						"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory," +
+						"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu," +
+						"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory," +
+						"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu," +
+						"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory," +
+						"kube_customresource_verticalpodautoscaler_spec_updatepolicy_updatemode",
+					"--custom-resource-state-config-file=/config/custom-resource-state.yaml",
 				}
 				serviceAccountName = "kube-state-metrics"
 			}

+			volumes = []corev1.Volume{{
+				Name: "custom-resource-state-config",
+				VolumeSource: corev1.VolumeSource{
+					ConfigMap: &corev1.ConfigMapVolumeSource{
+						LocalObjectReference: corev1.LocalObjectReference{
+							Name: "custom-resource-state-config",
+						},
+					},
+				},
+			}}
+
+			volumeMounts = []corev1.VolumeMount{{
+				Name:      "custom-resource-state-config",
+				MountPath: "/config",
+				ReadOnly:  true,
+			}}
+
 			if clusterType == component.ClusterTypeShoot {
 				deploymentLabels = map[string]string{
 					"component":           "kube-state-metrics",
@@ -305,18 +335,19 @@ var _ = Describe("KubeStateMetrics", func() {
 				args = []string{
 					"--port=8080",
 					"--telemetry-port=8081",
-					"--resources=daemonsets,deployments,nodes,pods,statefulsets,verticalpodautoscalers,replicasets",
+					"--resources=daemonsets,deployments,nodes,pods,statefulsets,replicasets",
 					"--namespaces=kube-system",
 					"--kubeconfig=/var/run/secrets/gardener.cloud/shoot/generic-kubeconfig/kubeconfig",
 					"--metric-labels-allowlist=nodes=[*]",
+					"--custom-resource-state-config-file=/config/custom-resource-state.yaml",
 				}
 				automountServiceAccountToken = ptr.To(false)
-				volumeMounts = []corev1.VolumeMount{{
+				volumeMounts = append(volumeMounts, corev1.VolumeMount{
 					Name:      "kubeconfig",
 					MountPath: "/var/run/secrets/gardener.cloud/shoot/generic-kubeconfig",
 					ReadOnly:  true,
-				}}
-				volumes = []corev1.Volume{{
+				})
+				volumes = append(volumes, corev1.Volume{
 					Name: "kubeconfig",
 					VolumeSource: corev1.VolumeSource{
 						Projected: &corev1.ProjectedVolumeSource{
@@ -349,7 +380,7 @@ var _ = Describe("KubeStateMetrics", func() {
 							},
 						},
 					},
-				}}
+				})
 			}

 			return &appsv1.Deployment{
@@ -469,7 +500,7 @@ var _ = Describe("KubeStateMetrics", func() {
 					{
 						SourceLabels: []monitoringv1.LabelName{"__name__"},
 						Action:       "keep",
-						Regex:        `^(kube_daemonset_metadata_generation|kube_daemonset_status_current_number_scheduled|kube_daemonset_status_desired_number_scheduled|kube_daemonset_status_number_available|kube_daemonset_status_number_unavailable|kube_daemonset_status_updated_number_scheduled|kube_deployment_metadata_generation|kube_deployment_spec_replicas|kube_deployment_status_observed_generation|kube_deployment_status_replicas|kube_deployment_status_replicas_available|kube_deployment_status_replicas_unavailable|kube_deployment_status_replicas_updated|kube_horizontalpodautoscaler_spec_max_replicas|kube_horizontalpodautoscaler_spec_min_replicas|kube_horizontalpodautoscaler_status_current_replicas|kube_horizontalpodautoscaler_status_desired_replicas|kube_horizontalpodautoscaler_status_condition|kube_namespace_annotations|kube_node_info|kube_node_labels|kube_node_spec_taint|kube_node_spec_unschedulable|kube_node_status_allocatable|kube_node_status_capacity|kube_node_status_condition|kube_persistentvolumeclaim_resource_requests_storage_bytes|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_status_restarts_total|kube_pod_info|kube_pod_labels|kube_pod_owner|kube_pod_spec_volumes_persistentvolumeclaims_info|kube_pod_status_phase|kube_pod_status_ready|kube_replicaset_owner|kube_statefulset_metadata_generation|kube_statefulset_replicas|kube_statefulset_status_observed_generation|kube_statefulset_status_replicas|kube_statefulset_status_replicas_current|kube_statefulset_status_replicas_ready|kube_statefulset_status_replicas_updated|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_target|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound|kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_minallowed|kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_maxallowed|kube_verticalpodautoscaler_spec_updatepolicy_updatemode)$`,
+						Regex:        `^(kube_daemonset_metadata_generation|kube_daemonset_status_current_number_scheduled|kube_daemonset_status_desired_number_scheduled|kube_daemonset_status_number_available|kube_daemonset_status_number_unavailable|kube_daemonset_status_updated_number_scheduled|kube_deployment_metadata_generation|kube_deployment_spec_replicas|kube_deployment_status_observed_generation|kube_deployment_status_replicas|kube_deployment_status_replicas_available|kube_deployment_status_replicas_unavailable|kube_deployment_status_replicas_updated|kube_horizontalpodautoscaler_spec_max_replicas|kube_horizontalpodautoscaler_spec_min_replicas|kube_horizontalpodautoscaler_status_current_replicas|kube_horizontalpodautoscaler_status_desired_replicas|kube_horizontalpodautoscaler_status_condition|kube_namespace_annotations|kube_node_info|kube_node_labels|kube_node_spec_taint|kube_node_spec_unschedulable|kube_node_status_allocatable|kube_node_status_capacity|kube_node_status_condition|kube_persistentvolumeclaim_resource_requests_storage_bytes|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_status_restarts_total|kube_pod_info|kube_pod_labels|kube_pod_owner|kube_pod_spec_volumes_persistentvolumeclaims_info|kube_pod_status_phase|kube_pod_status_ready|kube_replicaset_owner|kube_statefulset_metadata_generation|kube_statefulset_replicas|kube_statefulset_status_observed_generation|kube_statefulset_status_replicas|kube_statefulset_status_replicas_current|kube_statefulset_status_replicas_ready|kube_statefulset_status_replicas_updated|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory|kube_customresource_verticalpodautoscaler_spec_updatepolicy_updatemode)$`,
 					},
 				},
 			},
@@ -605,7 +636,7 @@ var _ = Describe("KubeStateMetrics", func() {
 					{
 						SourceLabels: []monitoringv1.LabelName{"__name__"},
 						Action:       "keep",
-						Regex:        `^(kube_daemonset_metadata_generation|kube_daemonset_status_current_number_scheduled|kube_daemonset_status_desired_number_scheduled|kube_daemonset_status_number_available|kube_daemonset_status_number_unavailable|kube_daemonset_status_updated_number_scheduled|kube_deployment_metadata_generation|kube_deployment_spec_replicas|kube_deployment_status_observed_generation|kube_deployment_status_replicas|kube_deployment_status_replicas_available|kube_deployment_status_replicas_unavailable|kube_deployment_status_replicas_updated|kube_node_info|kube_node_labels|kube_node_spec_taint|kube_node_spec_unschedulable|kube_node_status_allocatable|kube_node_status_capacity|kube_node_status_condition|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_status_restarts_total|kube_pod_info|kube_pod_labels|kube_pod_status_phase|kube_pod_status_ready|kube_replicaset_owner|kube_replicaset_metadata_generation|kube_replicaset_spec_replicas|kube_replicaset_status_observed_generation|kube_replicaset_status_replicas|kube_replicaset_status_ready_replicas|kube_statefulset_metadata_generation|kube_statefulset_replicas|kube_statefulset_status_observed_generation|kube_statefulset_status_replicas|kube_statefulset_status_replicas_current|kube_statefulset_status_replicas_ready|kube_statefulset_status_replicas_updated|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_target|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound|kube_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound|kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_minallowed|kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_maxallowed|kube_verticalpodautoscaler_spec_updatepolicy_updatemode)$`,
+						Regex:        `^(kube_daemonset_metadata_generation|kube_daemonset_status_current_number_scheduled|kube_daemonset_status_desired_number_scheduled|kube_daemonset_status_number_available|kube_daemonset_status_number_unavailable|kube_daemonset_status_updated_number_scheduled|kube_deployment_metadata_generation|kube_deployment_spec_replicas|kube_deployment_status_observed_generation|kube_deployment_status_replicas|kube_deployment_status_replicas_available|kube_deployment_status_replicas_unavailable|kube_deployment_status_replicas_updated|kube_node_info|kube_node_labels|kube_node_spec_taint|kube_node_spec_unschedulable|kube_node_status_allocatable|kube_node_status_capacity|kube_node_status_condition|kube_pod_container_info|kube_pod_container_resource_limits|kube_pod_container_resource_requests|kube_pod_container_status_restarts_total|kube_pod_info|kube_pod_labels|kube_pod_status_phase|kube_pod_status_ready|kube_replicaset_owner|kube_replicaset_metadata_generation|kube_replicaset_spec_replicas|kube_replicaset_status_observed_generation|kube_replicaset_status_replicas|kube_replicaset_status_ready_replicas|kube_statefulset_metadata_generation|kube_statefulset_replicas|kube_statefulset_status_observed_generation|kube_statefulset_status_replicas|kube_statefulset_status_replicas_current|kube_statefulset_status_replicas_ready|kube_statefulset_status_replicas_updated|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu|kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu|kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory|kube_customresource_verticalpodautoscaler_spec_updatepolicy_updatemode)$`,
 					},
 				},
 			},
@@ -725,6 +756,15 @@ var _ = Describe("KubeStateMetrics", func() {
 		By("Create secrets managed outside of this package for whose secretsmanager.Get() will be called")
 		Expect(c.Create(ctx, &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "generic-token-kubeconfig", Namespace: namespace}})).To(Succeed())

+		customResourceStateConfigMap = &corev1.ConfigMap{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "custom-resource-state-config",
+				Namespace: namespace,
+			},
+			Data: map[string]string{
+				"custom-resource-state.yaml": expectedCustomResourceStateConfig(),
+			},
+		}
 		serviceAccount = &corev1.ServiceAccount{
 			ObjectMeta: metav1.ObjectMeta{
 				Name:      "kube-state-metrics",
@@ -865,6 +905,7 @@ var _ = Describe("KubeStateMetrics", func() {
 					scrapeConfigCache,
 					scrapeConfigSeed,
 					scrapeConfigGarden,
+					customResourceStateConfigMap,
 				}

 				managedResourceSecret.Name = managedResource.Spec.SecretRefs[0].Name
diff --git a/pkg/component/observability/monitoring/kubestatemetrics/resources.go b/pkg/component/observability/monitoring/kubestatemetrics/resources.go
index c999d4050..0d74c400c 100644
--- a/pkg/component/observability/monitoring/kubestatemetrics/resources.go
+++ b/pkg/component/observability/monitoring/kubestatemetrics/resources.go
@@ -37,24 +37,28 @@ import (
 	kubernetesutils "github.com/gardener/gardener/pkg/utils/kubernetes"
 )

-func (k *kubeStateMetrics) getResourceConfigs(genericTokenKubeconfigSecretName string, shootAccessSecret *gardenerutils.AccessSecret) component.ResourceConfigs {
+func (k *kubeStateMetrics) getResourceConfigs(genericTokenKubeconfigSecretName string, shootAccessSecret *gardenerutils.AccessSecret, customResourceStateConfig string) component.ResourceConfigs {
 	var (
-		clusterRole         = k.emptyClusterRole()
-		clusterRoleBinding  = k.emptyClusterRoleBinding()
-		service             = k.emptyService()
-		deployment          = k.emptyDeployment()
-		vpa                 = k.emptyVerticalPodAutoscaler()
-		pdb                 = k.emptyPodDisruptionBudget()
-		scrapeConfigCache   = k.emptyScrapeConfigCache()
-		scrapeConfigSeed    = k.emptyScrapeConfigSeed()
-		scrapeConfigGarden  = k.emptyScrapeConfigGarden()
-		scrapeConfigShoot   = k.emptyScrapeConfigShoot()
-		prometheusRuleShoot = k.emptyPrometheusRuleShoot()
+		clusterRole                  = k.emptyClusterRole()
+		clusterRoleBinding           = k.emptyClusterRoleBinding()
+		service                      = k.emptyService()
+		deployment                   = k.emptyDeployment()
+		vpa                          = k.emptyVerticalPodAutoscaler()
+		pdb                          = k.emptyPodDisruptionBudget()
+		scrapeConfigCache            = k.emptyScrapeConfigCache()
+		scrapeConfigSeed             = k.emptyScrapeConfigSeed()
+		scrapeConfigGarden           = k.emptyScrapeConfigGarden()
+		scrapeConfigShoot            = k.emptyScrapeConfigShoot()
+		prometheusRuleShoot          = k.emptyPrometheusRuleShoot()
+		customResourceStateConfigMap = k.emptyCustomResourceStateConfigMap()

 		configs = component.ResourceConfigs{
 			{Obj: clusterRole, Class: component.Application, MutateFn: func() { k.reconcileClusterRole(clusterRole) }},
 			{Obj: service, Class: component.Runtime, MutateFn: func() { k.reconcileService(service) }},
 			{Obj: vpa, Class: component.Runtime, MutateFn: func() { k.reconcileVerticalPodAutoscaler(vpa, deployment) }},
+			{Obj: customResourceStateConfigMap, Class: component.Runtime, MutateFn: func() {
+				k.reconcileCustomResourceStateConfigMap(customResourceStateConfigMap, customResourceStateConfig)
+			}},
 		}
 	)

@@ -133,10 +137,15 @@ func (k *kubeStateMetrics) reconcileClusterRole(clusterRole *rbacv1.ClusterRole)
 			Resources: []string{"cronjobs", "jobs"},
 			Verbs:     []string{"list", "watch"},
 		},
+		{
+			APIGroups: []string{"apiextensions.k8s.io"},
+			Resources: []string{"customresourcedefinitions"},
+			Verbs:     []string{"list", "watch"},
+		},
 		{
 			APIGroups: []string{"autoscaling.k8s.io"},
 			Resources: []string{"verticalpodautoscalers"},
-			Verbs:     []string{"get", "list", "watch"},
+			Verbs:     []string{"list", "watch"},
 		},
 	}

@@ -223,16 +232,20 @@ func (k *kubeStateMetrics) reconcileDeployment(
 		}
 	)

+	customResourceStateConfigFile := customResourceStateConfigMountDir + "/" + customResourceStateConfigMountFile
+
 	if k.values.ClusterType == component.ClusterTypeSeed {
 		deploymentLabels[v1beta1constants.LabelRole] = v1beta1constants.LabelMonitoring
 		podLabels = utils.MergeStringMaps(podLabels, deploymentLabels, map[string]string{
 			v1beta1constants.LabelNetworkPolicyToRuntimeAPIServer: v1beta1constants.LabelNetworkPolicyAllowed,
 		})
+
 		args = append(args,
-			"--resources=deployments,pods,statefulsets,nodes,verticalpodautoscalers,horizontalpodautoscalers,persistentvolumeclaims,replicasets,namespaces",
+			"--resources=deployments,pods,statefulsets,nodes,horizontalpodautoscalers,persistentvolumeclaims,replicasets,namespaces",
 			"--metric-labels-allowlist=nodes=[*]",
 			"--metric-annotations-allowlist=namespaces=[shoot.gardener.cloud/uid]",
 			"--metric-allowlist="+strings.Join(cachePrometheusAllowedMetrics, ","),
+			"--custom-resource-state-config-file="+customResourceStateConfigFile,
 		)
 	}

@@ -242,10 +255,11 @@ func (k *kubeStateMetrics) reconcileDeployment(
 			gardenerutils.NetworkPolicyLabel(v1beta1constants.DeploymentNameKubeAPIServer, kubeapiserverconstants.Port): v1beta1constants.LabelNetworkPolicyAllowed,
 		})
 		args = append(args,
-			"--resources=daemonsets,deployments,nodes,pods,statefulsets,verticalpodautoscalers,replicasets",
+			"--resources=daemonsets,deployments,nodes,pods,statefulsets,replicasets",
 			"--namespaces="+metav1.NamespaceSystem,
 			"--kubeconfig="+gardenerutils.PathGenericKubeconfig,
 			"--metric-labels-allowlist=nodes=[*]",
+			"--custom-resource-state-config-file="+customResourceStateConfigFile,
 		)
 	}

@@ -303,8 +317,23 @@ func (k *kubeStateMetrics) reconcileDeployment(
 						corev1.ResourceMemory: resource.MustParse("32Mi"),
 					},
 				},
+				VolumeMounts: []corev1.VolumeMount{{
+					Name:      customResourceStateConfigMapName,
+					MountPath: customResourceStateConfigMountDir,
+					ReadOnly:  true,
+				}},
 			}},
 			PriorityClassName: k.values.PriorityClassName,
+			Volumes: []corev1.Volume{{
+				Name: customResourceStateConfigMapName,
+				VolumeSource: corev1.VolumeSource{
+					ConfigMap: &corev1.ConfigMapVolumeSource{
+						LocalObjectReference: corev1.LocalObjectReference{
+							Name: customResourceStateConfigMapName,
+						},
+					},
+				},
+			}},
 		},
 	}

@@ -449,12 +478,17 @@ var cachePrometheusAllowedMetrics = []string{
 	"kube_statefulset_status_replicas_current",
 	"kube_statefulset_status_replicas_ready",
 	"kube_statefulset_status_replicas_updated",
-	"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_target",
-	"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound",
-	"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound",
-	"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_minallowed",
-	"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_maxallowed",
-	"kube_verticalpodautoscaler_spec_updatepolicy_updatemode",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu",
+	"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory",
+	"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu",
+	"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory",
+	"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu",
+	"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory",
+	"kube_customresource_verticalpodautoscaler_spec_updatepolicy_updatemode",
 }

 func (k *kubeStateMetrics) emptyScrapeConfigCache() *monitoringv1alpha1.ScrapeConfig {
@@ -600,12 +634,17 @@ func (k *kubeStateMetrics) reconcileScrapeConfigShoot(scrapeConfig *monitoringv1
 		"kube_statefulset_status_replicas_current",
 		"kube_statefulset_status_replicas_ready",
 		"kube_statefulset_status_replicas_updated",
-		"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_target",
-		"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound",
-		"kube_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound",
-		"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_minallowed",
-		"kube_verticalpodautoscaler_spec_resourcepolicy_container_policies_maxallowed",
-		"kube_verticalpodautoscaler_spec_updatepolicy_updatemode",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu",
+		"kube_customresource_verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory",
+		"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu",
+		"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory",
+		"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu",
+		"kube_customresource_verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory",
+		"kube_customresource_verticalpodautoscaler_spec_updatepolicy_updatemode",
 	)
 }

@@ -726,3 +765,13 @@ func (k *kubeStateMetrics) nameSuffix() string {
 	}
 	return suffix + "-seed"
 }
+
+func (k *kubeStateMetrics) emptyCustomResourceStateConfigMap() *corev1.ConfigMap {
+	return &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: customResourceStateConfigMapName, Namespace: k.namespace}}
+}
+
+func (k *kubeStateMetrics) reconcileCustomResourceStateConfigMap(cm *corev1.ConfigMap, customResourceStateConfig string) {
+	cm.Data = map[string]string{
+		customResourceStateConfigMountFile: customResourceStateConfig,
+	}
+}
diff --git a/pkg/component/observability/monitoring/kubestatemetrics/testdata/custom-resource-state.expectation.yaml b/pkg/component/observability/monitoring/kubestatemetrics/testdata/custom-resource-state.expectation.yaml
new file mode 100644
index 000000000..a335c3014
--- /dev/null
+++ b/pkg/component/observability/monitoring/kubestatemetrics/testdata/custom-resource-state.expectation.yaml
@@ -0,0 +1,290 @@
+spec:
+  resources:
+  - metricNamePrefix: null
+    groupVersionKind:
+      group: autoscaling.k8s.io
+      version: v1
+      kind: VerticalPodAutoscaler
+    commonLabels: {}
+    labelsFromPath:
+      namespace:
+      - metadata
+      - namespace
+      target_api_version:
+      - spec
+      - targetRef
+      - apiVersion
+      target_kind:
+      - spec
+      - targetRef
+      - kind
+      target_name:
+      - spec
+      - targetRef
+      - name
+      verticalpodautoscaler:
+      - metadata
+      - name
+    metrics:
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_target_cpu
+      help: Target cpu the VerticalPodAutoscaler recommends for the container.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - target
+          - cpu
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: core
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_cpu
+      help: Maximum cpu the container can use before the VerticalPodAutoscaler updater
+        evicts it.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - upperBound
+          - cpu
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: core
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_cpu
+      help: Minimum cpu the container can use before the VerticalPodAutoscaler updater
+        evicts it.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - lowerBound
+          - cpu
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: core
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_cpu
+      help: Minimum cpu the VerticalPodAutoscaler can set for containers matching
+        the name.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - spec
+          - resourcePolicy
+          - containerPolicies
+          valueFrom:
+          - minAllowed
+          - cpu
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: core
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_cpu
+      help: Maximum cpu the VerticalPodAutoscaler can set for containers matching
+        the name.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - spec
+          - resourcePolicy
+          - containerPolicies
+          valueFrom:
+          - maxAllowed
+          - cpu
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: core
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_target_memory
+      help: Target memory the VerticalPodAutoscaler recommends for the container.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - target
+          - memory
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: byte
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_upperbound_memory
+      help: Maximum memory the container can use before the VerticalPodAutoscaler
+        updater evicts it.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - upperBound
+          - memory
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: byte
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_status_recommendation_containerrecommendations_lowerbound_memory
+      help: Minimum memory the container can use before the VerticalPodAutoscaler
+        updater evicts it.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - status
+          - recommendation
+          - containerRecommendations
+          valueFrom:
+          - lowerBound
+          - memory
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: byte
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_spec_resourcepolicy_containerpolicies_minallowed_memory
+      help: Minimum memory the VerticalPodAutoscaler can set for containers matching
+        the name.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - spec
+          - resourcePolicy
+          - containerPolicies
+          valueFrom:
+          - minAllowed
+          - memory
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: byte
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_spec_resourcepolicy_containerpolicies_maxallowed_memory
+      help: Maximum memory the VerticalPodAutoscaler can set for containers matching
+        the name.
+      each:
+        type: Gauge
+        gauge:
+          labelsFromPath:
+            container:
+            - containerName
+          path:
+          - spec
+          - resourcePolicy
+          - containerPolicies
+          valueFrom:
+          - maxAllowed
+          - memory
+          labelFromKey: ""
+          nilIsZero: true
+        stateSet: null
+        info: null
+      commonLabels:
+        unit: byte
+      labelsFromPath: {}
+      errorLogV: 0
+    - name: verticalpodautoscaler_spec_updatepolicy_updatemode
+      help: Update mode of the VerticalPodAutoscaler.
+      each:
+        type: StateSet
+        gauge: null
+        stateSet:
+          labelsFromPath: {}
+          path:
+          - spec
+          - updatePolicy
+          - updateMode
+          list:
+          - "Off"
+          - Initial
+          - Recreate
+          - Auto
+          labelName: update_mode
+          valueFrom: []
+        info: null
+      commonLabels: {}
+      labelsFromPath: {}
+      errorLogV: 0
+    errorLogV: 0
+    resourcePlural: ""
--
2.44.0
